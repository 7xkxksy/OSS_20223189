# 리눅스 명령어 **top, ps, jobs, kill** 조사

--------------------------------------------------------------------------------------

## 1. top (실시간 시스템 모니터링)

`top` 명령어는 시스템의 현재 상태와 프로세스들의 리소스(CPU, Memory) 사용량을 **실시간**으로 갱신하여 보여줍니다. 윈도우의 '작업 관리자'와 유사한 역할을 합니다.

### 📸 실습 화면


### 💡 주요 단축키
`top` 실행 중에 사용할 수 있는 핵심 단축키를 테이블로 정리했습니다.

| 단축키 | 기능 설명 | 비고 |
| :---: | :--- | :--- |
| **P** | **CPU 사용량** 순서로 정렬 | 기본값 |
| **M** | **메모리 사용량** 순서로 정렬 | 메모리 부족 시 확인 |
| **k** | 프로세스 종료 (Signal 전송) | PID 입력 필요 |
| **q** | top 명령어 종료 | |

---------------------------------------------------------------------------------------

## 2. ps (현재 프로세스 상태 확인)

`ps` (Process Status) 명령어는 현재 시스템에서 실행 중인 프로세스의 상태를 **스냅샷** 찍듯이 보여줍니다. `top`과 달리 특정 시점의 상태를 정적으로 출력합니다.

### 📸 실습 화면 (Screenshot)
![ps command screenshot](https://upload.wikimedia.org/wikipedia/commons/thumb/a/ad/Gnometerminal_3.6.0.png/640px-Gnometerminal_3.6.0.png)
*출처: Wikimedia Commons (Terminal execution example)*

### 💡 주요 옵션
`ps` 명령어는 옵션에 따라 출력되는 정보가 달라집니다. 가장 많이 쓰는 옵션을 표로 정리했습니다.

| 옵션 | 기능 설명 | 비고 |
| :---: | :--- | :--- |
| **-e** | 현재 실행 중인 **모든 프로세스** 출력 | System V 스타일 |
| **-f** | 프로세스 정보를 **완전한 포맷**으로 출력 | UID, PPID 등 포함 |
| **aux** | 실행 중인 모든 프로세스를 **사용자 중심**으로 출력 | BSD 스타일 |
| **grep** | 특정 프로세스만 검색할 때 조합해서 사용 | 예: `ps -ef \| grep ssh` |

### 💻 사용 예시
```bash
# 가장 표준적인 전체 프로세스 조회 방법
$ ps -ef

# 모든 프로세스 확인 (BSD 스타일)
$ ps aux

# 'python'이 들어간 프로세스만 검색
$ ps -ef | grep python

---------------------------------------------------------------------------------------

## 3. jobs (백그라운드 작업 확인)

`jobs` 명령어는 현재 쉘 세션에서 백그라운드로 실행 중이거나 중지된 **작업 목록**을 번호와 함께 보여줍니다.

### 📸 실습 화면 

### 💡 작업 상태 및 제어
`jobs` 출력 결과에 나오는 상태 값과 관련 기호/명령어에 대한 설명입니다.

| 항목 | 설명 | 비고 |
| :---: | :--- | :--- |
| **Running** | 현재 백그라운드에서 **실행 중**인 상태 | `&`를 붙여 실행 시 |
| **Stopped** | 작업이 일시 **중단된** 상태 | `Ctrl + Z` 입력 시 |
| **fg** | 백그라운드 작업을 **포그라운드**로 가져옴 | `fg %번호` |
| **bg** | 멈춘 작업을 **백그라운드**에서 실행시킴 | `bg %번호` |

### 💻 사용 예시
```bash
# sleep 명령어를 백그라운드(&)로 실행 후 목록 확인
$ sleep 1000 &
[1] 12345

$ jobs
[1]+  Running                 sleep 1000 &'''

-------------------------------------------------------------------------------------

## 4. kill (프로세스 종료)

`kill` 명령어는 특정 프로세스(PID)에 **시그널**을 보내어 작업을 제어하거나 종료합니다. 응답하지 않는 프로그램을 강제로 닫을 때 주로 사용합니다.

### 📸 실습 화면 

### 💡 주요 시그널
프로세스 종료 시 사용할 수 있는 시그널의 종류와 번호를 표로 정리했습니다.

| 시그널 번호 | 이름 | 설명 |
| :---: | :--- | :--- |
| **15** | **SIGTERM** | **정상 종료** 요청 (기본값). 저장할 시간을 줌 |
| **9** | **SIGKILL** | **강제 종료**. 프로세스를 즉시 제거함 (데이터 손실 주의) |
| **2** | **SIGINT** | **인터럽트**. 키보드 `Ctrl + C`와 동일한 효과 |
| **1** | **SIGHUP** | **재시작**. 설정 파일을 다시 읽어들일 때 사용 |

### 💻 사용 예시
```bash
# 1. PID 확인 (먼저 프로세스 번호를 알아야 함)
$ ps -ef | grep program_name

# 2. 종료 신호 전송 (PID가 1234일 경우)
$ kill 1234

# 3. 강제 종료 (반응이 없을 때 - 최후의 수단)
$ kill -9 1234'''
